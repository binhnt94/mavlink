workflow:
  # build branches and merge requests but not both at same time
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'


stages:
  - get_version
  - setup
  - build
  - test
  - release

# edit major and minor version numbers here
# when the minor number changes, the patch number will be reset to 0
variables:
  MAJOR: 4
  MINOR: 5

get-versions:
  stage: get_version
  tags:
    - quick

  resource_group: $CI_PROJECT_NAME-patch-number

  variables:
    FILE: s3://device-management.tools.swoop.aero/firmware/$CI_PROJECT_NAME-patch-numbers.json

  script:
    - aws s3 cp $FILE patch-numbers.json
    - PATCH=$(python3 get_patch_number.py -f patch-numbers.json --major $MAJOR --minor $MINOR)
    - aws s3 cp patch-numbers.json $FILE
    - echo "PATCH=$PATCH" >> variables.env

  artifacts:
    reports:
      dotenv: variables.env

# setup version numbers and variables
setup:
  tags:
    - quick

  stage: setup

  script:
    - BUILDNAME=mavlink-$CI_COMMIT_SHORT_SHA-$MAJOR-$MINOR-$PATCH
    - BINARY=swoop_pymavlink-$MAJOR.$MINOR.$PATCH-cp38-cp38-linux_x86_64.whl
    - echo $BUILDNAME
    # save some variables to variable.env to use in following jobs
    - echo "PATCH=$PATCH" >> variables.env
    - echo "BUILDNAME=$BUILDNAME" >> variables.env
    - echo "VERSION=$MAJOR.$MINOR.$PATCH" >> variables.env
    - echo "TAG=v$MAJOR.$MINOR.$PATCH" >> variables.env
    - echo "BINARY=$BINARY" >> variables.env
    # generate metadata file for use by downstream systems (e.g. maintenance screen firmware upgrade)
    - >
      JSON_STRING=$( jq -n
      --arg br  "$CI_COMMIT_REF_SLUG"
      --arg sha "$CI_COMMIT_SHORT_SHA"
      --arg trg "$CI_PIPELINE_SOURCE"
      --arg id  "$CI_PIPELINE_ID"
      --arg iid "$CI_PIPELINE_IID"
      --arg tme "$CI_PIPELINE_CREATED_AT"
      --arg usr "$GITLAB_USER_NAME"
      --arg maj "$MAJOR"
      --arg min "$MINOR"
      --arg pat "$PATCH"
      --arg bin "$BINARY"
      '{branch: $br, sha: $sha, iid: $iid, id: $id, time: $tme, user: $usr, trig: $trg, major: $maj, minor: $min, patch: $pat, binary: $bin}' )
    - echo $JSON_STRING
    - echo $JSON_STRING > ci_metadata.json

  artifacts:
    paths:
      - ci_metadata.json
    reports:
      dotenv: variables.env

build:
  stage: build
  image: quay.io/pypa/manylinux_2_28_x86_64
  tags:
    - quick

  variables:
    GIT_SUBMODULE_STRATEGY: recursive

  script:
    - export MDEF=$(pwd)/message_definitions
    - export VERSION=$MAJOR.$MINOR.$PATCH
    - cd pymavlink
    - |
      for PYBIN in /opt/python/*/bin; do
          "${PYBIN}/pip" install install -U future lxml
          "${PYBIN}/pip" wheel --wheel-dir=wheels/ .
      done

  artifacts:
    name: "pymavlink_$VERSION_$CI_COMMIT_SHORT_SHA"
    paths:
      - "pymavlink/wheels/*"

# push the binaries and metadata to s3 bucket and create a tag for cross referencing
release:
  stage: release
  tags:
    - quick

  variables:
    BASE_FILE_NAME: s3://device-management.tools.swoop.aero/firmware/mavlink/$CI_COMMIT_BRANCH

  script:
    - cp -r message_definitions pymavlink/
    - cd pymavlink/
    - echo -en $MAJOR.$MINOR.$PATCH > version.txt
    - python3 setup.py sdist
    - cd ..
    - pip install s3pypi==1.0.0rc3
    - s3pypi pymavlink/wheels/* pymavlink/dist/* --bucket device-management.tools.swoop.aero --prefix firmware/pypi
    #- aws s3 cp pymavlink/$BINARY $BASE_FILE_NAME/$BINARY
    - aws s3 cp ci_metadata.json $BASE_FILE_NAME/$BUILDNAME.config
    - curl --location --output /usr/local/bin/release-cli "https://release-cli-downloads.s3.amazonaws.com/latest/release-cli-linux-amd64"
    - chmod +x /usr/local/bin/release-cli
    - release-cli -v
    - echo 'running release_job for $TAG'
  release:
    name: '$CI_COMMIT_REF_SLUG $TAG'
    tag_name: '$TAG'
    ref: '$CI_COMMIT_SHA'
    description: '$CI_COMMIT_REF_SLUG $TAG'
